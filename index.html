<!DOCTYPE html>
<html>
  <head>
    <title>Scala, The Good Parts</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .looper {
        background-image: url(images/looper2.jpg);
        background-size: 100%;
      }
      .question {
        background: #f92672;
        color: white;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>

    <textarea id="source">
name: looper
layout: true
class: looper

---
name: question
layout: true
class: center, middle, question

---
name: inverse
layout: true
class: center, middle, inverse

---

class: center, middle

# Scala, The Good Parts

<img src="images/looper.jpg" width="600px" />

---
layout: false

# Me

<img src="images/ambiata.png" width="300px" />

<img src="http://ambiata.com/images/ambiata_avatar.png" />

- Charles O'Farrell
- [@charlesofarrell](https://twitter.com/charlesofarrell)

---

## Scala, The Good Parts

<img src="images/js-good-parts.jpg">

---

## Scala, The Good Parts (jokes aside)

<a href="http://www.manning.com/bjarnason/">
  <img src="images/book.jpg" width="300px" />
</a>

---

## Correctness

- Protecting code from your future self

<img src="images/looper2.jpg" />

---

## Grab bag

- Default arguments
- Implicit configuration
- Value discard
- Exhausive checking
- Performance XXXX
- Automatic releases

---



template: inverse

# Default arguments

---
layout: false

## Default arguments (Java)

```java
public void example(String host) {
  example(host, 80)
}

public void example(String host, int port) {
  ...
}
```

---

## Default arguments (Scala)

```scala
def example(host: String, port: Int = 80) = ...
```

---
template: question

## So what's the problem?

---
layout: false

## Works today

```scala
def getBytes(string: String): Array[Byte] =
  string.getBytes

def elsewhere =
  getBytes("hello")
```

---

## Bugs!

```scala
def getBytes(string: String, charset: Charset = Charset("UTF-8")): Array[Byte] =
  string.getBytes(charset)

def elsewhere =
  getBytes("hello")
```

---

## Propagation

```scala
def something(i: Int = 10) =
  ...
```

---

## Propagation (Part 2)

```scala
def something(i: Int = 10) =
  ...

def somethingElse(s: String, i: Int = 10) =
  something(i)
```

---

## Propagation (Part 3)

```scala
def something(i: Int = 10) =
  ...

def somethingElse(s: String, i: Int = 10) =
  something(i)

def willItNeverEnd(s: String, i: Int = 10) =
  somethingElse(s, i)
```

---

## Reasoning

- Correctness is more important than convenience
- Default arguments are a bug waiting to happen
- Ambiata has a rule about _no_ default arguments
  - Pass everything explicitly

---

## Real use cases

Instead of:

```scala
connectHTTP(host: String, port: Int = 80, ssl: Boolean = false)
```

Why not:

```scala
connectHTTP(host: String)
connectHTTPS(host: String)
connectHTTPPort(host: String, port: Int)
```

---

# Another example

```scala
object Configuration {
  def production(address: InetSocketAddress): Configuration = ...
  def testing: Configuration = ...
}
```

---

## More

- Interesting discussion
  - "Default arguments are insane"
  - https://github.com/typelevel/wartremover/issues/116
- Bugs in the wild
  - https://issues.scala-lang.org/browse/SI-3322
  - TODO FIND SOME MORE!!!

---














template: inverse

# Implicit configuration

---
layout: false

## Use implicit arguments instead!

```scala
object Encoder {

  def getBytes(s: String)(implicit codec: Codec): Array[Byte] =
    s.getBytes(codec.charSet)
}
```

---

## Example

```scala
import scala.io._

object Example {
  
  implicit val codec = Codec.UTF8

  def doSomething: Unit =
    println(Encoder.getBytes("hello 草"))
}
```

---

## Can you move code?

- Move the function from file A to B
- Does this have the same behaviour/meaning?
  - And would you notice while refactoring?

```scala
import scala.io._

object Example2 {

  def doSomething: Unit =
    println(Encoder.getBytes("hello 草"))
}
```

---

template: looper

---

## Funny story

- I actually got a bug trying to write that example
- Implicit scoping rules, picked up wrong encoding :/

---

## Implicit resources

```scala
def run(s: String)(implicit ec: ExecutionContext) = ...

object Pool {
  implicit val tc: ExecutionContext =
    ExecutionContext.fromExecutor(java.util.concurrent.Executors.newCachedThreadPool())
}

import Pool._

object Main {
  def args(args: Array[String]): Unit = {
    run("hello")
    // Will this program terminate?
  }
}
```

---

## Implicit resources

- Who is responsible for closing/cleaning-up resources?
- http://stackoverflow.com/questions/25879496/how-to-exit-a-program-properly-when-using-scalaz-futures-and-the-timed-function

---
template: question

# At Ambiata we have this crazy technique...

---
template: question

# ...function arguments

---

## Crazy talk

```scala
def run(s: String, ec: ExecutionContext) = ...

object Pool {
  def withEC[A](f: ExecutionContext => A): A = {
    val pool = java.util.concurrent.Executors.newCachedThreadPool
    val result = f(ExecutionContext.fromExecutor(pool))
    pool.shutdown()
    result
  }
}

object Main {
  def args(args: Array[String]): Unit = {
    Pool.withEC { ec =>
      run("hello", ec)
    }
  }
}
```

---

template: ambiata

## What we do at Ambiata

- Pass arguments manually
  - Crazy!
  - But no accidental bugs!!!
- Use Reader Monad
  - Just function composition
  - Talk for another day

---












template: inverse

# Pattern Matching

---
layout: false

## ADTs FTW

```scala
sealed trait Encoding
case object StringEncoding extends Encoding
case object IntEncoding extends Encoding
```

```scala
def asString(encoding: Encoding): String = encoding match {
  case StringEncoding => "string"
  case IntEncoding    => "int"
}
```

---

template: question

## So far so good

---

## Until...

```scala
case object DateEncoding extends Encoding
```

---

## Boom!

```scala
> asString(DateEncoding)
scala.matchError: DateEncoding
  at .asString()
```

---

template: looper

---

## Warnings are useless

```
[warn] .../src/main/scala/PatternMatching.scala:8: match may not be exhaustive.
[warn] It would fail on the following input: DateEncoding
[warn]   def asString(encoding: Encoding): String = encoding match {
[warn]                                              ^
[warn]
```

---

## Warnings as errors

```scala
scalacOptions in Compile ++= Seq("-Xfatal-warnings")
```

- Scala equivalent of `-Wall -Werror`

---

## Phew

```
[error] .../src/main/scala/PatternMatching.scala:8: match may not be exhaustive.
[error] It would fail on the following input: DateEncoding
[error]   def asString(encoding: Encoding): String = encoding match {
[error]                                              ^
[error]
```

---

## Wildcards are bad too

```scala
def asString(encoding: Encoding): String = encoding match {
  case StringEncoding => "string"
  case _              => "int"
}
```

```
> asString(DateEncoding)
res0: String = int
```

---

## Word of warning

- Exhaustive checking in Scala is not perfect

```scala
def asString(encoding: Encoding): String = encoding match {
  case StringEncoding if ... => "string"
}
```

```
> asString(DateEncoding)
scala.MatchError: DateEncoding (of class PatternMatching$DateEncoding$)
        at PatternMatching$.asString2(PatternMatching.scala:13)
```

---

## Fold

```scala
trait Encoding {
  def fold[A](s: => A, i: => A): A = this match {
    case StringEncoding => s
    case IntEncoding    => i
  }
}

def asString(encoding: Encoding): String =
  encoding.fold("string", "int")
```

---

## Fold

```scala
trait Encoding {
  def fold[A](s: => A, i: => A, d: => A): A = this match {
    case StringEncoding => s
    case IntEncoding    => i
    case DateEncoding   => d
  }
}

def asString(encoding: Encoding): String =
  encoding.fold("string", "int", "date")
```

---








template: inverse

# Value Discard

---
layout: false

## Spot the bug

```scala

def load(id: Int): IO[Dictionary] = ...
def save(id: Int, dictionary: Dictionary): IO[Unit] = ...

def setName(id: Int, name: String): IO[Unit] =
  load(id).map(dictionary => 
    save(id, dictionary.copy(name = name))
  )
```

---

## Whoops

```scala

def setName(id: String, name: String): IO[IO[Unit]] =
    load(id).map(dictionary =>
      save(id, dictionary.copy(name = name))
    )
```

---

template: looper

---

## Compiler flag

```scala
scalacOptions in Compile ++= Seq(
    "-Ywarn-value-discard"
  )
```

---

## Warning

```
[warn] .../src/main/scala/ValueDiscard.scala:18: discarded non-Unit value
[warn]     load(id).map(dictionary => save(id, dictionary.copy(name = name)))
[warn]                                    ^
```

---

## Errors FTW

```scala
scalacOptions in Compile ++= Seq(
    "-Ywarn-value-discard"
  , "-Xfatal-warnings"
  )
```

---

## Much better

```
[error] .../src/main/scala/ValueDiscard.scala:18: discarded non-Unit value
[error]     load(id).map(dictionary => save(id, dictionary.copy(name = name)))
[error]                                    ^
```

---

## Fixed

```scala

def setName(id: String, name: String): IO[Unit] =
  load(id).flatMap(dictionary =>
    save(id, dictionary.copy(name = name))
  )
```

---

## Burned in Real Life

- https://github.com/ambiata/mundane/commit/25ec5a32b952f1e8ce4f0516a3c52e4520ae05d5

---




template: inverse

# Type-Safe Equals

---
## Wat

```scala
def foo: String =
  "1"

def bar: Int
  1

def wat: Boolean
  foo == bar

scala> wat
res0: Boolean = false
```

---
template: question

## Why the f**k does that even compile?

---
## Scalaz FTW

```scala
import scalaz._, Scalaz._

def foo: String =
  "1"

def bar: Int
  1

// Doesn't compile
// def phew: Boolean
//  foo === bar
```

---

## Another example

```scala
trait Seq[A] {
  def contains(elem: Any): Boolean = { ... }
}

scala> List("1").contains(1)
res0: Boolean = false
```

---







template: inverse

# Return Types

---
## What is the return type?

```scala
def foo(strings: List[String]) = for {
    s &lt;- strings
  } yield bar(s)

val size = foo(List("a", "b", "c")).size
```

---
template: question

## What happens if 'bar' changes?
```

---

template: looper

---
## Always use return types

```scala
def foo1(strings: List[String]): List[String] = for {
    s &lt;- strings
  } yield bar1(s)

def foo2(strings: List[String]): List[List[String]] = for {
    s &lt;- strings
  } yield bar2(s)
```

---

template: ambiata

# Ambiata

- _Always_ have return types for top-level methods
  - No surprises
  - Easier to review

---







template: inverse

# Seq

---
layout:false

## What is the runtime performance of this function?

```scala
def foo[A](a: A, s: Seq[A]): Seq[A] = { ... }

foo(1, (1 to 10).toList)
```

## What about now?

```scala
def prepend[A](a: A, s: Seq[A]): Seq[A] =
  s :+ a

prepend(1, (1 to 10).toList)
```

## What about NOW?

```scala
def foo[A](s: Seq[A]): Seq[A] =
  s.size

foo(Stream.continually(1))
```

---

template: ambiata

# Ambiata

- _Never_ use `Seq`
  - Honestly we mostly use `List`

---










template: inverse

# Property-based testing

---
layout:false

## ScalaCheck

- ScalaCheck is the norm
  - Only a handful of "unit" tests
- Has changed my life
- So important it deserves it's own talk
  - Declan is speaking next month
- Do it. Seriously.

---







template: inverse

# Dependency Management

---

<img src="images/ambiata_github.png" width="500" /> 

---

## Ambiata

- We like small, self-contained modules
- But, how often do we "release"?
- Maven SNAPSHOTs are evil
  - Non-repeatable builds

---

## Problem - Versions

- 3.0.0
- 3.0.1
- 3.1.0
- ...


- How do you choose the version number?
- What does it even mean?

---

## Promulgate

- https://github.com/ambiata/promulgate

```scala
import com.ambiata.promulgate.project.ProjectPlugin._

object build extends Build {
  lazy val core = Project(
    settings = promulgate.library("com.ambiata.something", "ambiata-oss")
  )
}
```

---

## Very simple idea

- Release on _every_ build
- Use the Git hash
  - Easy to know/find what changed
- Upload to S3
- That's it!
- Can be done in [insert build tool]

---

## Conflict

- Which one do you take?

```
&lt;&lt;&lt;
val mundane = Seq("com.ambiata" % "mundane-io" %% "1.0.0-c5dab77")
===
val mundane = Seq("com.ambiata" % "mundane-io" %% "1.0.0-db04e5e")
>>>
```

---

## Timestamp

```
&lt;&lt;&lt;
val mundane = Seq("com.ambiata" % "mundane-io" %% "1.0.0-20140322013124-c5dab77")
===
val mundane = Seq("com.ambiata" % "mundane-io" %% "1.0.0-20140422013124-db04e5e")
>>>
```

---

## Future

- Definitely not ideal
- Upgrading downstream dependencies and ensuring compatibility
- [Annex](http://www.youtube.com/watch?v=JjYAnBhF2JU)

---

## SBT Tip: Source dependencies

```scala
object source extends Build {

  lazy val ref =
    Project("ivory", file("."))
      .dependsOn(RootProject(file("../mundane")))
}
```

---



template: inverse

# Conclusion

<img src="images/luke.jpg" />

---

layout: false

# Conclusion

- Correctness over convenience. Always.
- Protect your future self!
- Slides - http://charleso.github.com/scala-the-good-parts
- Check out [Looper](http://www.imdb.com/title/tt1276104/). :)

---

## Read this. Seriously.

<a href="http://www.manning.com/bjarnason/">
  <img src="images/book.jpg" width="300px" />
</a>



    </textarea>
    <script src="http://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>.
